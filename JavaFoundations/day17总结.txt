1：泛型(理解)
	(1)泛型类
		class Demo<QQ> {
			public void show(QQ qq) {
				...
			}
		}
	(2)泛型方法
		class Demo {
			public <T> void method(T t) {
				...
			}
		}
	(3)泛型接口
		interface Inter<QQ> {
			void show(QQ qq);
		}

		//方式1
		class InterImpl implements Inter<String> {
			public void show(String s){
				
			}
		}
		
		//方式2
		class InterImpl<QQ> implements Inter<QQ> {
			public void show(QQ qq){
				...
			}
		}

2：Set(掌握)
	(1)Collection 
		List 有序，可重复。
		Set 无序，唯一。
	(2)HashSet	
		如何保证元素唯一性的呢?
		底层数据结构是哈希表(散列表)。具体的是由一个元素是单向链表的数组组成。
		它依赖于两个方法：hashCode()和equals()方法。
		执行顺序：
			先判断hashCode()是否相同，
				如果相同
					继承执行equals()方法，看其返回值：
						true:元素重复，不存储。
						false:元素不重复，存储。
				如果不同
					存储。
		
		记住：
			看到HashXxx结构的集合，就要知道，被该集合存储的元素要重写hashCode()和equals()方法。
			而且，是自动生成的。
	(3)TreeSet	
		底层数据结构是二叉树。

		如何保证元素的唯一性的呢?
			根据比较的返回值是否是0来决定。
		如何保证元素的排序的呢?
			A:自然排序 元素具备比较性
				让集合中被存储的元素所属的类实现Comparable接口。
			B:比较器排序 集合具备比较性
				在创建集合对象的时候，让构造方法接收一个Comparator接口的子类对象。
	(4)LinkedHashSet
		底层由链表和哈希表组成。
		由链表保证有序。
		由哈希表保证唯一。
	(5)案例：
		HashSet:
			存储String
			存储Student
			存储Person
		TreeSet:
			存储String
			存储Integer
			存储Student
			存储Person

3：静态导入(了解)
	(1)以前的导入是导入到类的级别，现在可以通过静态导入导入到方法的级别。
	(2)格式：
		import static java.xxx.xxx.方法名;

		注意：
			要能看懂这种东西，自己一般不用。

4：可变参数(理解)
	(1)针对在写一个方法的时候，不知道具体要有多少个形式参数的时候。
	   java提供了可变参数的用法。
	(2)格式：
		修饰符 返回值类型 方法名(数据类型... 变量) {
		
		}

		注意：
			A:变量其实是该数据类型的一个数组。
			B:形式参数如果有多个的话，可变参数只能是最后一个。
			C:数据类型要一致。
	(3)Arrays工具类的asList方法的使用。
		注意：用数组转换后的集合的长度不能发生改变。